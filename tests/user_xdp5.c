/*
 * Tool for accessing eBPF maps generated by P4, at tests/
 * gcc -I ../lib/ ../lib/libbpf.o xdp5_user.c  
 */
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <linux/bpf.h>
#include <errno.h>
#include <string.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include "libbpf.h"
#include "xdp5.h"

// we might want to put this into header
#define MAP_PATH            "/sys/fs/bpf/xdp/globals/dstmactable"
#define DEFAULT_MAP_PATH    "/sys/fs/bpf/xdp/globals/dstmactable_defaultAction"

#define CONTROL_PLANE 1
#if CONTROL_PLANE
void initialize_tables()
{
    int fd;

    fd = bpf_obj_get(DEFAULT_MAP_PATH);
    if (fd < 0) {
        printf("BPF map %s not loaded\n", DEFAULT_MAP_PATH);
        exit(1);
    }

    u32 ebpf_zero = 0;
    {
        struct dstmactable_value value = {
            .action = Fallback_action,
        };
        assert(bpf_update_elem(fd, &ebpf_zero, &value, BPF_ANY) == 0);
    }
}
#endif

int main(void)
{
	int ret;	
    int fd;
	struct dstmactable_key key;
	struct dstmactable_value value;

    /* populate the default table */
	initialize_tables();

	value.action = Fallback_action;
	key.field0 = 0x800;

    printf("=== Open BPF map: %s ===\n", MAP_PATH);
    fd = bpf_obj_get(MAP_PATH);
    if (fd < 0) {
        printf("BPF map %s not loaded\n", MAP_PATH);
        exit(1);
    }

    /* populate the match-action table */
    printf("=== Write to eBPF map ===\n");
    printf("key = %x value = %x\n", key.field0, value.action);
    ret = bpf_update_elem(fd, &key, &value, BPF_ANY);
    if (ret) {
        perror("error updating map element\n");
        exit(1);
    }
        
    return 0;
}

